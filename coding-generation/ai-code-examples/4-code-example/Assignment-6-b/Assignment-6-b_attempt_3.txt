import numpy as np
import matplotlib.pyplot as plt

def monte_carlo_pi(n_points):
    x = np.random.rand(n_points)
    y = np.random.rand(n_points)
    inside_circle = x**2 + y**2 <= 1
    pi_estimate = 4 * np.sum(inside_circle) / n_points
    return pi_estimate

def monte_carlo_unit_ball_volume(n_points, dim):
    points = np.random.uniform(-1, 1, (n_points, dim))
    distances = np.linalg.norm(points, axis=1)
    inside_ball = distances <= 1
    volume_estimate = (2**dim) * np.sum(inside_ball) / n_points
    return volume_estimate

def simulate_integration_error(n_points, dimensions):
    theoretical_scaling = 1 / np.sqrt(n_points)
    results = np.zeros((len(dimensions)+1, len(n_points)))
    
    for i, dim in enumerate(dimensions):
        errors = []
        for n in n_points:
            volume_estimates = [monte_carlo_unit_ball_volume(int(n), dim) for _ in range(10)]
            error = np.std(volume_estimates)
            errors.append(error)
        results[i] = errors
    results[-1] = theoretical_scaling
    return results

def f(x):
    return 1 + 2/(1 + x**2) + np.cos(np.sqrt(3*x))**2

def genSample(n):
    x = np.linspace(0, 10, 1000)
    y = f(x)
    normalization_constant = np.trapz(y, x)
    max_f = np.max(y)
    
    samples = []
    while len(samples) < n:
        u = np.random.uniform(0, 10)
        v = np.random.uniform(0, max_f)
        if v < f(u)/normalization_constant:
            samples.append(u)
    
    return np.array(samples)

n_samples = 10000
generated_samples = genSample(n_samples)

plt.hist(generated_samples, bins=100, density=True)
x = np.linspace(0, 10, 1000)
y = f(x)
normalization_constant = np.trapz(y, x)
plt.plot(x, y/normalization_constant, 'r-', lw=2)
plt.title("Distribution of values generated by genSample()")
plt.xlabel("x")
plt.ylabel("Probability Density")
plt.show()