import numpy as np
import matplotlib.pyplot as plt

# Define the function for Monte Carlo estimation of pi
def findPi(n_points):
    points = np.random.rand(n_points, 2)
    inside_circle = (points[:, 0]**2 + points[:, 1]**2) < 1
    estimated_pi = 4 * np.sum(inside_circle) / n_points
    return estimated_pi

# Define the function for Monte Carlo estimation of volume of unit ball in 'dim' dimensions
def integrate(n_points, dim):
    points = np.random.uniform(-1, 1, (n_points, dim))
    inside_ball = np.linalg.norm(points, axis=1) < 1
    estimated_volume = 2**dim * np.sum(inside_ball) / n_points
    return estimated_volume

# Initialize variables
n_points = np.logspace(2, 6, num=50, dtype=int)
dimensions = [2, 5, 10, 20]
results = np.zeros((len(dimensions)+1, len(n_points)))
results[-1, :] = 1/np.sqrt(n_points)

# Loop over dimensions and number of points
for i, dim in enumerate(dimensions):
    for j, n in enumerate(n_points):
        results[i, j] = integrate(n, dim)

# Function to generate sample of x values distributed according to the given function
def genSample(npts):
    def func(x):
        return 1 + 2/(1 + x**2) + np.cos(np.sqrt(3*x))**2
    norm = integrate(1000000, 1)  # Calculate normalizing constant
    x_values = np.random.rand(npts) * 10
    y_values = func(x_values) / norm
    return x_values, y_values

# Plotting the values generated by the function
x, y = genSample(1000)
plt.figure(figsize=(10, 6))
plt.hist(x, bins=50, weights=y, edgecolor='black')
plt.title("Distribution of values generated according to the given function")
plt.xlabel("x")
plt.ylabel("Density")
plt.show()


::: Task :::


# Import necessary libraries
import numpy as np
import matplotlib.pyplot as plt

# Define the function for Monte Carlo estimation of pi
def findPi(n_points):
    points = np.random.rand(n_points, 2)
    inside_circle = (points[:, 0]**2 + points[:, 1]**2) < 1
    estimated_pi = 4 * np.sum(inside_circle) / n_points
    return estimated_pi

# Define the function for Monte Carlo estimation of volume of unit ball in 'dim' dimensions
def integrate(n_points, dim):
    points = np.random.uniform(-1, 1, (n_points, dim))
    inside_ball = np.linalg.norm(points, axis=1) < 1
    estimated_volume = 2**dim * np.sum(inside_ball) / n_points
    return estimated_volume

# Initialize variables
n_points = np.logspace(2, 6, num=50, dtype=int)
dimensions = [2, 5, 10, 20]
results = np.zeros((len(dimensions)+1, len(n_points)))
results[-1, :] = 1/np.sqrt(n_points)

# Loop over dimensions and number of points
for i, dim in enumerate(dimensions):
    for j, n in enumerate(n_points):
        results[i, j] = integrate(n, dim)

# Function to generate sample of x values distributed according to the given function
def genSample(npts):
    def func(x):
        return 1 + 2/(1 + x**2) + np.cos(np.sqrt(3*x))**2
    norm = integrate(1000000, 1)  # Calculate normalizing constant
    x_values = np.random.rand(npts) * 10
    y_values = func(x_values) / norm
    return x_values, y_values

# Plotting the values generated by the function
x, y = genSample(1000)
plt.figure(figsize=(10, 6))
plt.hist(x, bins=50, weights=y, edgecolor='black')
plt.title("Distribution of values generated according to the given function")
plt.xlabel("x")
plt.ylabel("Density")
plt.show()