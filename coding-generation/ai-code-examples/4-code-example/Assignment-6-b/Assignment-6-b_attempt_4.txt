import numpy as np
import matplotlib.pyplot as plt

def monte_carlo_pi(n_points):
    x = np.random.rand(n_points)
    y = np.random.rand(n_points)
    inside = (x**2 + y**2) <= 1
    pi_estimate = 4 * np.sum(inside) / n_points
    return pi_estimate

def monte_carlo_volume(n_points, dim):
    points = np.random.uniform(-1, 1, (n_points, dim))
    distances = np.sqrt(np.sum(points**2, axis=1))
    inside = distances <= 1
    volume_estimate = (2**dim) * np.sum(inside) / n_points
    return volume_estimate

def integration_error(dim, n_points):
    results = np.zeros((dim, len(n_points) + 1))
    theoretical_scaling = 1 / np.sqrt(n_points)
    for d in range(1, dim + 1):
        for i in range(len(n_points)):
            n = n_points[i]
            volume_estimate = monte_carlo_volume(n, d)
            true_volume = np.pi**(d / 2) / np.math.gamma(d / 2 + 1)
            error = np.abs(volume_estimate - true_volume)
            results[d-1, i] = error
        results[d-1, -1] = theoretical_scaling[-1]
    return results

def genSample(n_samples):
    def pdf(x):
        return 1 + 2/(1+x**2) + np.cos(np.sqrt(3*x))**2
    x = np.linspace(0, 10, 1000)
    y = pdf(x)
    normalization = np.trapz(y, x)
    max_pdf = np.max(y)
    
    samples = []
    while len(samples) < n_samples:
        u = np.random.uniform(0, 10)
        v = np.random.uniform(0, max_pdf)
        if v <= pdf(u) / normalization:
            samples.append(u)
    
    return np.array(samples)

samples = genSample(10000)
plt.hist(samples, bins=50, density=True)
plt.title('Distribution of values generated by genSample')
plt.xlabel('Value')
plt.ylabel('Frequency')
plt.show()