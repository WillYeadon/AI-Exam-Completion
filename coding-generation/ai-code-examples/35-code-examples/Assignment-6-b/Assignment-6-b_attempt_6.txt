import numpy as np
import matplotlib.pyplot as plt

# Function to estimate pi using Monte Carlo method
def estimate_pi(n_points):
    points = np.random.rand(n_points, 2)
    inside_circle = points[:, 0]**2 + points[:, 1]**2 < 1
    pi_estimate = 4 * np.sum(inside_circle) / n_points
    return pi_estimate

# Function to estimate volume of a unit ball in d dimensions
def estimate_volume_unit_ball(dim, n_points):
    points = np.random.uniform(-1, 1, (n_points, dim))
    inside_ball = np.sum(points**2, axis=1) < 1
    volume_estimate = 2**dim * np.sum(inside_ball) / n_points
    return volume_estimate

# Function to simulate integration error scaling
def integration_error_scaling(n_points, dimensions):
    results = np.zeros((len(dimensions)+1, len(n_points)))
    
    for i, dim in enumerate(dimensions):
        for j, n in enumerate(n_points):
            volume_estimate = estimate_volume_unit_ball(dim, n)
            # Calculate theoretical error scaling
            error_scaling = 2**dim / (n * np.sqrt(n))
            results[i, j] = np.abs(volume_estimate - np.pi)  # Store absolute error
            results[-1, j] = error_scaling  # Store theoretical error scaling
            
    return results

# Function to generate samples based on custom probability distribution
def genSample(n_samples):
    x = np.linspace(0, 10, n_samples)
    func = 1 + 2/(1+x**2) + np.cos(np.sqrt(3*x))**2
    norm = np.trapz(func, x)
    samples = np.random.choice(x, n_samples, p=func/norm)
    return samples

# Verify the distribution of values generated by genSample()
n_samples = 1000
samples = genSample(n_samples)

plt.figure(figsize=(10, 6))
plt.hist(samples, bins=30, color='skyblue', edgecolor='black', alpha=0.7)
plt.title('Distribution of Values Generated by genSample()')
plt.xlabel('Value')
plt.ylabel('Frequency')
plt.show()