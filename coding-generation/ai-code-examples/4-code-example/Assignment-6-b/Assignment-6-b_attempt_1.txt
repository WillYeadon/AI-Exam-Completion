import numpy as np
import matplotlib.pyplot as plt

def monte_carlo_pi(n_points):
    x = np.random.uniform(-1, 1, n_points)
    y = np.random.uniform(-1, 1, n_points)
    inside_circle = x**2 + y**2 <= 1
    pi_estimate = 4 * np.sum(inside_circle) / n_points
    return pi_estimate

def monte_carlo_volume_unit_ball(dim, n_points):
    points = np.random.uniform(-1, 1, (n_points, dim))
    inside_ball = np.sum(points**2, axis=1) <= 1
    volume_estimate = (2**dim) * np.sum(inside_ball) / n_points
    return volume_estimate

def simulate_integration_error(dim, n_points_list):
    error_results = []
    for n_points in n_points_list:
        volume_estimates = [monte_carlo_volume_unit_ball(dim, n_points) for _ in range(100)]
        error = np.std(volume_estimates) / np.sqrt(n_points)
        error_results.append(error)
    return error_results

n_points_list = [10**i for i in range(1, 7)]
dims = [2, 5, 10]
results = np.zeros((len(dims)+1, len(n_points_list)))

for i, dim in enumerate(dims):
    results[i, :] = simulate_integration_error(dim, n_points_list)
results[-1, :] = 1 / np.sqrt(np.array(n_points_list))

x_graph = np.log10(n_points_list)

for i, dim in enumerate(dims):
    plt.plot(x_graph, np.log10(results[i]), label=f'{dim}D')
plt.plot(x_graph, np.log10(results[-1]), label='1/sqrt(N)', linestyle='--')
plt.xlabel('log10(N)')
plt.ylabel('log10(Error)')
plt.legend()
plt.title('Integration Error Scaling with Number of Points and Dimension')
plt.show()

def probability_density_function(x):
    return 1 + 2/(1 + x**2) + np.cos(np.sqrt(3*x))**2

def normalize_function():
    x = np.linspace(0, 10, 1000)
    pdf = probability_density_function(x)
    return np.trapz(pdf, x)

def gen_sample(n_samples):
    normalization_factor = normalize_function()
    x_vals = np.linspace(0, 10, 1000)
    pdf = probability_density_function(x_vals) / normalization_factor
    max_pdf = np.max(pdf)
    
    samples = []
    while len(samples) < n_samples:
        x = np.random.uniform(0, 10)
        y = np.random.uniform(0, max_pdf)
        if y <= probability_density_function(x) / normalization_factor:
            samples.append(x)
    return np.array(samples)

n_samples = 10000
samples = gen_sample(n_samples)

plt.hist(samples, bins=50, density=True, label='Generated Sample Distribution')
x = np.linspace(0, 10, 1000)
plt.plot(x, probability_density_function(x) / normalize_function(), label='Target Probability Density Function')
plt.xlabel('x')
plt.ylabel('Density')
plt.title('Distribution of values generated by genSample()')
plt.legend()
plt.show()